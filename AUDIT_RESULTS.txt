# AdvEngine Code Audit Results

This document presents a comprehensive audit of the AdvEngine codebase, identifying areas for improvement in stability, error handling, code style (PEP8, docstrings), UI modernization (Libadwaita), and overall code organization. No code changes have been made.

## 1. Stability and Error Handling

**Observation:** The current error handling relies heavily on `print()` statements, especially within the `ProjectManager`. While useful for debugging, this is not a robust solution for a user-facing application. A user will not see these console messages, leaving them unaware of potential data loading or saving failures.

**Recommendation:**
- **Implement a Logging System:** Replace `print()` statements with a proper logging framework (e.g., Python's built-in `logging` module). This allows for different log levels (DEBUG, INFO, WARNING, ERROR) and can be configured to write to a file, which would be invaluable for diagnosing user-reported issues.
- **User-Facing Error Dialogs:** For critical errors that the user needs to know about (e.g., failing to save the project), the `ProjectManager` should not just print an error. It should have a mechanism to propagate the error up to the UI layer, which can then display a user-friendly `Adw.MessageDialog`.
- **Transaction-like Saving:** A failure during the `save_project` method could leave the project in a partially saved, corrupted state. Consider a more transactional approach: write all data to temporary files first, and only if all writes succeed, replace the original files.

## 2. Code Style and Docstrings

**Observation:** The codebase is generally well-formatted, but there are inconsistencies. Docstrings, while present, could be more detailed and consistently follow the Google style guide as mandated by `AGENTS.md`.

**Recommendation:**
- **Strict PEP8 Enforcement:** Run a linter like `flake8` or `pylint` over the entire codebase to identify and fix all PEP8 violations.
- **Comprehensive Docstrings:** All modules, classes, and functions should have complete Google-style docstrings. This includes documenting all arguments, return values, and exceptions raised.
- **Automated Formatting:** Use a tool like `black` or `yapf` to ensure consistent code formatting, removing any arguments about style.

## 3. UI Improvements and Libadwaita Adherence

**Observation:** The UI is functional but shows a mix of older GTK patterns and newer Libadwaita widgets. To fully align with GNOME HIG, a more consistent adoption of Libadwaita is needed. The dynamic loading of editor modules in `main.py` is functional but can be sensitive to errors.

**Recommendation:**
- **Consistent Adwaita Usage:** Replace `Gtk.FileChooserNative` with `Adw.FileDialog`, and ensure all dialogs are `Adw.MessageDialog` or `Adw.AlertDialog` for a consistent look and feel. Review all `.ui` files to replace `Gtk.Box` with `Adw.PreferencesGroup` and `Gtk.ListBoxRow` with `Adw.ActionRow` where appropriate for forms and lists.
- **Robust Editor Discovery:** The `discover_and_add_editors` method in `main.py` should have more robust error handling. An error in one editor module should not prevent the rest of the application from loading. The error should be logged, and perhaps a placeholder or error message could be displayed in its place in the sidebar.
- **Use of `Adw.Toast`:** For non-critical notifications (e.g., "Project Saved"), use `Adw.Toast` overlays instead of dialogs to provide less intrusive feedback.

## 4. Code Organization and Refactoring

**Observation:** The codebase exhibits significant code duplication and some files have grown too large, indicating a need for refactoring and better organization.

**Recommendation:**
- **Split `data_schemas.py`:** This file is currently over 500 lines long and defines more than 20 classes. It should be split into smaller, more manageable modules within a `src/core/schemas/` directory (e.g., `item.py`, `character.py`, `scene.py`). This would greatly improve readability and maintainability.
- **Refactor `ProjectManager`:**
    - The `_load_*` and `_save_*` methods are highly repetitive. A generic helper method could handle the logic for loading/saving any JSON or CSV file based on a configuration dictionary that maps data types to filenames and dataclasses.
    - The `add_*` and `remove_*` methods are also boilerplate. A generic `add_to_collection(collection_name, item)` and `remove_from_collection(collection_name, item)` could be used, reducing the number of methods by over 80%.
- **Refactor GObject Wrappers:** The `GObject` wrappers in `data_schemas.py` contain a lot of repeated boilerplate code for property initialization and signal connection. A factory function or a metaclass could be used to generate these wrappers dynamically, reducing the code size and potential for errors.
- **Directory Structure:** The current structure is good, but introducing a `src/utils/` directory for common helper functions (e.g., UI loaders, file helpers) could further improve the separation of concerns. The `widgets` directory inside `src/ui/` is a good pattern that should be used for any custom, reusable widgets.

## 5. Separation of Concerns

**Observation:** The separation between the data layer (`core`) and the UI layer (`ui`) is well-defined, which is a major strength of the architecture.

**Recommendation:**
- **Maintain Strict Boundaries:** Continue to enforce this separation. The UI should *never* directly manipulate data files; all data access must go through the `ProjectManager`.
- **Callbacks and Signals:** The use of callbacks (`register_dirty_state_callback`) is a good pattern. This could be expanded to a more formal signal-based system (e.g., using a simple observer pattern or a library) to further decouple the `ProjectManager` from the UI. For instance, instead of just a "dirty" signal, there could be signals for `item-added`, `scene-changed`, etc., allowing different parts of the UI to update more granularly.
